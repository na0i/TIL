# 02.09 TIL

1. Flatten

   ```python
   # 빌딩 높이의 최댓값 찾기
   def max_h():
       # 최댓값 초기화 => 일단 1번째 높이를 최댓값으로 설정
       max_h = height[0]
       # 높이 인덱스 초기화 => 인덱스 0부터 시작
       max_h_idx = - 1
       # 빌딩을 한 개씩 순회하면서
       for i in range(len(height)):
           # 만약 i번째 빌딩이 최댓값보다 크면
           if height[i] > max_h:
               # 최댓값은 i번째 빌딩 높이
               max_h = height[i]
               # 인덱스에 몇번째인지(i) 저장
               max_h_idx = i
       # 몇번째 빌딩이 가장 높은지 저장
       return max_h_idx
   
   # 빌딩 높이의 최솟값 찾기
   def min_h():
       # 최솟값 초기화 => 일단 1번째 높이를 최솟값으로 설정
       min_h = height[0]
       # 높이 인덱스 초기화 => 인덱스 0부터 시작
       min_h_idx = - 1
       # 빌딩을 한 개씩 순회하면서
       for j in range(len(height)):
           # 만약 j번째 빌딩이 최솟값보다 작으면
           if height[j] < min_h:
               # 최솟값은 j번째 빌딩 높이
               min_h = height[j]
               # 인덱스에 몇번째인지(j) 저장
               min_h_idx = j
       # 몇번째 빌딩이 가장 낮은지 저장
       return min_h_idx
   
   # 테스트 케이스를 1 - 10까지 순회
   for tc in range(1, 11):
       # 테스트 케이스 순회할 때마다 정수 n을 입력 = flatten 횟수
       n = int(input())
       # 테스트 케이스 순회할 때마다 높이 입력 후 정수 리스트로 변환
       height = list(map(int, input().split()))
       # flatten 횟수 1씩 차감하며 반복
       while n > 0:
           # flatten할 때마다 가장 높은 빌딩 -1
           height[max_h()] -= 1
           # flatten할 때마다 가장 낮은 빌딩 +1
           height[min_h()] += 1
           n -= 1
       print("#{} {}".format(tc, height[max_h()] - height[min_h()]))
       
   # flatten 코드 개요
   flatten 1회마다 가장 높은 빌딩에서 -1, 가장 낮은 빌딩에 +1 을 실행해야함
   - 가장 높은 빌딩 찾기
   - 가장 낮은 빌딩 찾기
   - 1회마다 가장 높은 빌딩과 가장 낮은 빌딩에 flatten 실행
   - flatten 실행 후 '가장 높은 빌딩높이 - 가장 낮은 빌딩 높이' 값 출력
   ```

   

2. 소인수분해

   ```python
   T = int(input())
   
   # 소인수 분해 함수 정의 - 숫자 입력
   def prime_number(num):
       # 2, 3, 5, 7, 9의 지수 개수를 담기 위해 길이가 5인 리스트 생성
       abcde = [0] * 5
       # 소수 목록
       p_n = [2, 3, 5, 7, 11]
       # num을 소인수로 나누기 반복
       while num > 1:
           # idx는 0부터 4까지
           for idx in range(len(abcde)):
               # 만약 num이 p_n의 소수로 나누어진다면
               if num % p_n[idx] == 0:
                   # 같은 인덱스의 지수개수 리스트에 +1
                   abcde[idx] += 1
                   num = num / p_n[idx]
   
       return abcde
   
   for tc in range(T):
       N = int(input())
       print("#{} {} {} {} {} {}".format(tc + 1, prime_number(N)[0], prime_number(N)[1], prime_number(N)[2],prime_number(N)[3], prime_number(N)[4]))
       
   # 소인수분해 개요
   - 지수 개수를 담을 리스트 필요
   - 2, 3, 5, 7, 9로 나누어 지는지
   - 2, 3, 5, 7, 9로 나누어 질때마다 각 숫자당 +1
   - for로 인덱스 돌리면 1번 나누고 끝일 수 있으니 while로 n이 다 나누어질때까지 반복
   ```

   

3. 현주의 상자

   ```python
   T = int(input())
   N, Q = map(int, input().split())
   def hj_box():
   	box = [0] * N
   	for q in range(1, Q + 1):
   		l, r = map(int, input().split())
   		for i in range(r - l + 1):
   			box[r - i - 1] = q
   	return box
   
   for tc in range(T):
       print('#{}'.format(tc+1), *hj_box())
   ```



1. gravitiy

   ```python
   for t in range(4):
       N = int(input())
       g = list(map(int, input().split()))
   
       def gravity(N, g):
           max_g = g[0]
           for i in range(len(g)):
               if max_g <= g[i]:
                   max_g = g[i]
   
           count = 0
           for j in range(len(g)):
               if g[j] == max_g:
                   count += 1
   
           result = N - count
           return result
   
       print(gravity(N, g))
   ```

2. minmax

   ```python
   T = int(input())
   
   def max(numbers):
       max = numbers[0]
       for idx in range(len(numbers)):
           if numbers[idx] > max:
               max = numbers[idx]
       return max
   
   def min(numbers):
       min = numbers[0]
       for idx in range(len(numbers)):
           if numbers[idx] < min:
               min = numbers[idx]
       return min
   
   def min_max(numbers):
       result = max(numbers) - min(numbers)
       return result
   
   for tc in range(T):
       n= int(input())
       numbers = list(map(int, input().split()))
       print("#{} {}".format(tc + 1, min_max(numbers)))
   ```

3. 구간합

   ```python
   T = int(input())
   
   def part_sum(numbers):
       sort_numbers = []
       for idx in range(len(numbers)-pl+1):
           part = numbers[idx : idx+pl]
           p_sum = 0
           for p in part:
               p_sum += p
           sort_numbers.append(p_sum)
   
       for i in range(len(sort_numbers)-1, 0, -1):
           for j in range(0, i):
               if sort_numbers[j] > sort_numbers[j+1]:
                   sort_numbers[j], sort_numbers[j + 1] = sort_numbers[j + 1], sort_numbers[j]
       result = sort_numbers[len(sort_numbers)-1] - sort_numbers[0]
       return result
   
   for tc in range(T):
       l, pl = map(int, input().split())
       numbers = list(map(int, input().split()))
       print("#{} {}".format(tc + 1, part_sum(numbers)))
   ```

4. 숫자카드

   ```python
   T = int(input())
   
   for tc in range(T):
       n = int(input())
       numbers = list(input())
   
       count = [0] * 10
       for num in numbers:
           count[int(num)] += 1
   
       index = 0
       often_card = 0
       for i in range(len(count)):
           if count[i] >= often_card:
               often_card = count[i]
               index = i
   
       print("#{} {} {}".format(tc + 1, index, often_card))
   ```

   